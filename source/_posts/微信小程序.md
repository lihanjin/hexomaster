---
title: 微信小程序
date: 2017-01-11 12:21:13
tags: Wechat
categories: Wechat
---
## 微信小程序
<br/>
https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html
### 一、创建项目
> app.js、app.json、`app.wxss` 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。

- 1.`app.js`文件
	-`app.js` app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。想了解更多可用 API，可参考 API 文档
	
```
//app.js
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync('logs') || []
    logs.unshift(Date.now())
    wx.setStorageSync('logs', logs)
  },
  getUserInfo:function(cb){
    var that = this;
    if(this.globalData.userInfo){
      typeof cb == "function" && cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo;
              typeof cb == "function" && cb(that.globalData.userInfo)
            }
          })
        }
      });
    }
  },
  globalData:{
    userInfo:null
  }
})
```

```
App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync('logs') || []
    logs.unshift(Date.now())
    wx.setStorageSync('logs', logs)
  },

  run(){

    console.log('app里面的run方法');
  },
  getMsg(){

    console.log('app里面的getMsg方法');
  }
 
})
```
- 2`.app.json`
	- app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。更多可配置项可参考配置详解
```
	{
  "pages":[

    "pages/button/button",  
     "pages/index/index",  
    "pages/shop/shop",  
    "pages/home/home",  
     "pages/news/news",    
    "pages/logs/logs",
    "pages/newscontent/newscontent"
    //相当于路由器
  ],
  "window":{
    "backgroundTextStyle":"light",//文字颜色
    "navigationBarBackgroundColor": "#000",//头部导航文字颜色
    "navigationBarTitleText":"微信",//头部内容
    "navigationBarTextStyle":"#fff"//头部字体颜色只有黑色和白色默认黑色
  },
  "tabBar": {
//这里配置导航
    "color":"#666",
//字体颜色
    "selectedColor":"#f60",
//选择适合字体颜色
    "backgroundColor":"#fffeee",
//背景颜色
    "borderStyle":"white",
   //上边框颜色只有白色和黑色
    "position":"bottom",
    //定位
    "list": [{
      "pagePath": "pages/index/index",
      "iconPath":"static/images/home1.png",
      //图片图标

      "selectedIconPath":"static/images/home2.png",
      //选择以后的图标
      "text": "首页"
    }, {
      "pagePath": "pages/logs/logs",
       "iconPath":"static/images/log1.png",

      "selectedIconPath":"static/images/log2.png",
      "text": "日志"
    },{
      "pagePath": "pages/news/news",
        "iconPath":"static/images/news1.png",

      "selectedIconPath":"static/images/news2.png",
      "text": "新闻"
    }]
  }
}
```
- 3.``app.wxss``
	- `app.wxss` 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 `app.wxss` 中声明的样式规则。

```
	/**`app.wxss`**/
.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
}
```

### 二、创建页面

	 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。
- 1.index.wxml 是页面的结构文件

```
	<!--index.wxml-->
<view class="container">
  <view  bindtap="bindViewTap" class="userinfo">
    <image class="userinfo-avatar" src="{{userInfo.avatarUrl}}" background-size="cover"></image>
    <text class="userinfo-nickname">{{userInfo.nickName}}</text>
  </view>
  <view class="usermotto">
    <text class="user-motto">{{motto}}</text>
  </view>
</view>
```
本例中使用了`<view/>`、`<image/>`、`<text/>`来搭建页面结构，绑定数据和交互处理函数。`view==div  image==img text==p`

- 2.index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。

```
//index.js
//获取应用实例
var app = getApp()
Page({
  data: {
    motto: 'Hello World',
    userInfo: {}
  },
  //事件处理函数
  bindViewTap: function() {
    wx.navigateTo({
      url: '../logs/logs'
    })
  },
  onLoad: function () {
    console.log('onLoad')
    var that = this
    //调用应用实例的方法获取全局数据
    app.getUserInfo(function(userInfo){
      //更新数据
      that.setData({
        userInfo:userInfo
      })
    })
  }
})
```
getApp()
我们提供了全局的 getApp() 函数，可以获取到小程序实例。

```
// other.js
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

注意：

App() 必须在 app.js 中注册，且不能注册多个。

不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。

不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。

通过 getApp() 获取实例之后，不要私自调用生命周期函数。
<br/>
-3 .index.wxss 是页面的样式表：

```
/**index.wxss**/
.userinfo {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.userinfo-avatar {
  width: 128rpx;
  height: 128rpx;
  margin: 20rpx;
  border-radius: 50%;
}

.userinfo-nickname {
  color: #aaa;
}

.usermotto {
  margin-top: 200px;
}
```
###三、逻辑层
- 1.注册程序
	- `App()` 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。
	- https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html
	- getApp()
我们提供了全局的 getApp() 函数，可以获取到小程序实例。

```
// other.js
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

注意：

App() 必须在 app.js 中注册，且不能注册多个。

不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。

不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。

通过 getApp() 获取实例之后，不要私自调用生命周期函数。


### 四、注册页面
- 1.初始化数据

渲染层可以通过 WXML 对数据进行绑定。

示例代码：

```
<view>{{text}}</view>
<view>{{array[0].msg}}</view>
```
```
Page({
  data: {
    text: 'init data',
    array: [{msg: '1'}, {msg: '2'}]
  }
})
data相当于数据
```
- 2.onLoad参数
	- 页面相关事件处理函数
onPullDownRefresh: 下拉刷新
onReachBottom: 上拉触底
onPageScroll: 页面滚动
onShareAppMessage: 用户转发
- 3.事件处理函数
	`<view bindtap="viewTap"> click me </view>`
```
	Page({
  viewTap: function() {
    console.log('view tap')
  }
})
```
Page.prototype.route;route 字段可以获取到当前页面的路径。
this.setData用于改变data数据
### 五、路由
实例代码：
```
<navigator url="../home/home?aid=123" hover-class="navigator-hover">
  <button type="primary">跳转到home</button>


</navigator>
```
注意不能跳转到tab里面包含的页面
![Alt text](./1500641947179.png)
### 六、模块化
通过全局函数 getApp() 可以获取全局的应用实例，如果需要全局的数据可以在 App() 中设置，如：

```
// app.js
App({
  globalData: 1
})
```
```
// a.js
// The localValue can only be used in file a.js.
var localValue = 'a'
// Get the app instance.
var app = getApp()
// Get the global data and change it.
app.globalData++
```
```
// b.js
// You can redefine localValue in file b.js, without interference with the localValue in a.js.
var localValue = 'b'
// If a.js it run before b.js, now the globalData shoule be 2.
console.log(getApp().globalData)
```
####模块化
我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。

需要注意的是：

exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。
小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中。
使用模块还是通过require或者是import from

Tips
- 1. tip: require 暂时不支持绝对路径
###七、API
https://mp.weixin.qq.com/debug/wxadoc/dev/api/
##逻辑层
###一、数据绑定

- 1.简单绑定
	- `<view>{{message}}</view>
- 2.组件属性（需要在双引号之内）
	- <view id='item-{{id}}'></view>
- 3.控制属性（需要在双引号之内）
	- `<view wx:if="{{condition}}"> </view>`
- 4.关键字（需要在双引号之内）
	- true,false
	- `<checkbox checked="{{false}}"></checkbox>`
- 5.运算
	- 可以在{{}}内进行简单的运算，支持有如下几种方式：
	- 三元运算
		- `<view hidden="{{flag?true:false}}">Hidden</view>`
	- 算数运算
		- `<view>{{a+b}}+{{c}}+d</view>`
	- 逻辑判断
		- `<view wx:if="{{length>5}}"></view>`
	- 字符串运算
		- `<view>{{"hello"+name}}</view>` 
	- 数据路径运算
		- `<view>{{object.key}}{{array[0]}</view>` 
	- 6. 组合，可以在mustache内进行直接祝贺，构成新的对象或者数组
		- 数组
			- `<view wx:for={{[0,1,2,3,4]}}>{{item}}</view>`
			- 最终组合成数组[0,1,2,3,4]
		- 对象
			- `<template is="objectCombine" data="{{for:a,bar:b}}</template>` 
			- 最终组合的对象是{{for:1,bar:2}}
			-  也可以用扩展运算符 ... 来将一个对象展开
			-  `<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>`
			-  最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}。
			-  如果对象的 key 和 value 相同，也可以间接地表达。
			-  

		```
		<template is="objectCombine" data="{{foo, bar}}"></template>
		Page({
		  data: {
		    foo: 'my-foo',
		    bar: 'my-bar'
		  }
		})
		```

最终组合成的对象是 `{foo: 'my-foo', bar:'my-bar'}。`
TIPS：
如果花括号里面有空格最终将被解析成字符串
### 二、列表渲染
- 1.wx:for
	- 通过`wx:for`循环数组
		-可以通过`wx:for-item`可以指定元素的变量名
	- 通过`wx:for-index`可以指定数组当前下标的变量名

	- 

	```
		<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
		  {{idx}}: {{itemName.message}}
		</view>
	```
- 2.block wx:for
	- 类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：
	

```
<block wx:for="{{[1, 2, 3]}}">
  <view> {{index}}: </view>
  <view> {{item}} </view>
</block>
```
- 3.wx:key
	- 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <input/> 中的输入内容，<switch/> 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。

wx:key 的值以两种形式提供

		- 1字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。
- 2保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字

### 二、条件渲染
- 1.wx:if
	- 在框架中，我们用 wx:if="{{condition}}" 来判断是否需要渲染该代码块：
		- `<view wx:if="{{condition}}"> True </view>`
	- 也可以用 wx:elif 和 wx:else 来添加一个 else 块：
	

				```
			 <view wx:if="{{length > 5}}"> 1 </view>
			<view wx:elif="{{length > 2}}"> 2 </view>
			<view wx:else> 3 </view>
			```
- 2.block wx:if
	- block/> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

```
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```

### 二、模板
WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。
- 1.定义模板
	- 使用name属性，作为模板的名字。然后在

```
<template/>内定义代码片段，如：
	- <!--
  index: int
  msg: string
  time: string
-->
<template name="msgItem">
  <view>
    <text> {{index}}: {{msg}} </text>
    <text> Time: {{time}} </text>
  </view>
</template>
```
- 2.使用模板
	- 使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如：
	- `<template is="msgItem" data="{{...item}}"/>`
### 三、事件
- 1.bindtap，绑定事件
	- `<view id="tapTest" data-hi="WeChat" bindtap="tapName"> Click me! </view>`
- 2.在相应的Page定义中写上相应的事件处理函数，参数是event。
	- 

```
 Page({
  tapName: function(event) {
    console.log(event)
  }
})
```
https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html
### 五、引用

WXML 提供两种文件引用方式import和include。

- 1.import
  - import可以在该文件中使用目标文件定义的template，如：

在 item.wxml 中定义了一个叫item的template：

```
<!-- item.wxml -->
<template name="item">
  <text>{{text}}</text>
</template>
```

在 index.wxml 中引用了 item.wxml，就可以使用item模板：

```
<import src="item.wxml"/>
<template is="item" data="{{text: 'forbar'}}"/>
```

import 的作用域
import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。

如：C import B，B import A，在C中可以使用B定义的template，在B中可以使用A定义的template，但是C不能使用A定义的template。

```
<!-- A.wxml -->
<template name="A">
  <text> A template </text>
</template>
<!-- B.wxml -->
<import src="a.wxml"/>
<template name="B">
  <text> B template </text>
</template>
<!-- C.wxml -->
<import src="b.wxml"/>
<template is="A"/>  <!-- Error! Can not use tempalte when not import A. -->
<template is="B"/>
```

include
include可以将目标文件除了<template/>的整个代码引入，相当于是拷贝到include位置，如：

```
<!-- index.wxml -->
<include src="header.wxml"/>
<view> body </view>
<include src="footer.wxml"/>
<!-- header.wxml -->
<view> header </view>
<!-- footer.wxml -->
<view> footer </view>
```